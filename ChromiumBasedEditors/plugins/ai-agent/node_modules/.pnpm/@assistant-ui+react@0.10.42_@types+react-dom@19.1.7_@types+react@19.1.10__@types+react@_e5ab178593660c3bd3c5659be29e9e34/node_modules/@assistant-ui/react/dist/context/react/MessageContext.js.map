{"version":3,"sources":["../../../src/context/react/MessageContext.ts"],"sourcesContent":["\"use client\";\n\nimport { createContext } from \"react\";\nimport { ReadonlyStore } from \"../ReadonlyStore\";\nimport { MessageUtilsState } from \"../stores/MessageUtils\";\nimport { createContextHook } from \"./utils/createContextHook\";\nimport { createContextStoreHook } from \"./utils/createContextStoreHook\";\nimport { UseBoundStore } from \"zustand\";\nimport { MessageRuntime } from \"../../api/MessageRuntime\";\nimport { createStateHookForRuntime } from \"./utils/createStateHookForRuntime\";\nimport { EditComposerRuntime } from \"../../api\";\n\nexport type MessageContextValue = {\n  useMessageRuntime: UseBoundStore<ReadonlyStore<MessageRuntime>>;\n  useMessageUtils: UseBoundStore<ReadonlyStore<MessageUtilsState>>;\n};\n\nexport const MessageContext = createContext<MessageContextValue | null>(null);\n\nconst useMessageContext = createContextHook(\n  MessageContext,\n  \"a component passed to <ThreadPrimitive.Messages components={...} />\",\n);\n\n/**\n * Hook to access the MessageRuntime from the current context.\n *\n * The MessageRuntime provides access to message-level state and actions,\n * including message content, status, editing capabilities, and branching.\n *\n * @param options Configuration options\n * @param options.optional Whether the hook should return null if no context is found\n * @returns The MessageRuntime instance, or null if optional is true and no context exists\n *\n * @example\n * ```tsx\n * function MessageActions() {\n *   const runtime = useMessageRuntime();\n *\n *   const handleReload = () => {\n *     runtime.reload();\n *   };\n *\n *   const handleEdit = () => {\n *     runtime.startEdit();\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleReload}>Reload</button>\n *       <button onClick={handleEdit}>Edit</button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useMessageRuntime(options?: {\n  optional?: false | undefined;\n}): MessageRuntime;\nexport function useMessageRuntime(options?: {\n  optional?: boolean | undefined;\n}): MessageRuntime | null;\nexport function useMessageRuntime(options?: {\n  optional?: boolean | undefined;\n}) {\n  const context = useMessageContext(options);\n  if (!context) return null;\n  return context.useMessageRuntime();\n}\n\n/**\n * Hook to access the current message state.\n *\n * This hook provides reactive access to the message's state, including content,\n * role, status, and other message-level properties.\n *\n * @param selector Optional selector function to pick specific state properties\n * @returns The selected message state or the entire message state if no selector provided\n *\n * @example\n * ```tsx\n * function MessageContent() {\n *   const role = useMessage((state) => state.role);\n *   const content = useMessage((state) => state.content);\n *   const isLoading = useMessage((state) => state.status.type === \"running\");\n *\n *   return (\n *     <div className={`message-${role}`}>\n *       {isLoading ? \"Loading...\" : content.map(part => part.text).join(\"\")}\n *     </div>\n *   );\n * }\n * ```\n */\nexport const useMessage = createStateHookForRuntime(useMessageRuntime);\n\nconst useEditComposerRuntime = (opt: {\n  optional: boolean | undefined;\n}): EditComposerRuntime | null => useMessageRuntime(opt)?.composer ?? null;\nexport const useEditComposer = createStateHookForRuntime(\n  useEditComposerRuntime,\n);\n\nexport const { useMessageUtils, useMessageUtilsStore } = createContextStoreHook(\n  useMessageContext,\n  \"useMessageUtils\",\n);\n"],"mappings":";;;AAEA,SAAS,qBAAqB;AAG9B,SAAS,yBAAyB;AAClC,SAAS,8BAA8B;AAGvC,SAAS,iCAAiC;AAQnC,IAAM,iBAAiB,cAA0C,IAAI;AAE5E,IAAM,oBAAoB;AAAA,EACxB;AAAA,EACA;AACF;AAwCO,SAAS,kBAAkB,SAE/B;AACD,QAAM,UAAU,kBAAkB,OAAO;AACzC,MAAI,CAAC,QAAS,QAAO;AACrB,SAAO,QAAQ,kBAAkB;AACnC;AA0BO,IAAM,aAAa,0BAA0B,iBAAiB;AAErE,IAAM,yBAAyB,CAAC,QAEE,kBAAkB,GAAG,GAAG,YAAY;AAC/D,IAAM,kBAAkB;AAAA,EAC7B;AACF;AAEO,IAAM,EAAE,iBAAiB,qBAAqB,IAAI;AAAA,EACvD;AAAA,EACA;AACF;","names":[]}