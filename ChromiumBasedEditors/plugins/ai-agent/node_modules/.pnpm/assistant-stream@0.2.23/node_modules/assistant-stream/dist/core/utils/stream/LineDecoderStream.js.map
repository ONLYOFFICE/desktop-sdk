{"version":3,"sources":["../../../../src/core/utils/stream/LineDecoderStream.ts"],"sourcesContent":["export class LineDecoderStream extends TransformStream<string, string> {\n  private buffer = \"\";\n\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        this.buffer += chunk;\n        const lines = this.buffer.split(\"\\n\");\n\n        // Process all complete lines\n        for (let i = 0; i < lines.length - 1; i++) {\n          controller.enqueue(lines[i]);\n        }\n\n        // Keep the last incomplete line in the buffer\n        this.buffer = lines[lines.length - 1] || \"\";\n      },\n      flush: () => {\n        // If there's content in the buffer when the stream ends, it means\n        // the stream ended with an incomplete line (no trailing newline)\n        if (this.buffer) {\n          throw new Error(\n            `Stream ended with an incomplete line: \"${this.buffer}\"`,\n          );\n        }\n      },\n    });\n  }\n}\n"],"mappings":";AAAO,IAAM,oBAAN,cAAgC,gBAAgC;AAAA,EAC7D,SAAS;AAAA,EAEjB,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW,CAAC,OAAO,eAAe;AAChC,aAAK,UAAU;AACf,cAAM,QAAQ,KAAK,OAAO,MAAM,IAAI;AAGpC,iBAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AACzC,qBAAW,QAAQ,MAAM,CAAC,CAAC;AAAA,QAC7B;AAGA,aAAK,SAAS,MAAM,MAAM,SAAS,CAAC,KAAK;AAAA,MAC3C;AAAA,MACA,OAAO,MAAM;AAGX,YAAI,KAAK,QAAQ;AACf,gBAAM,IAAI;AAAA,YACR,0CAA0C,KAAK,MAAM;AAAA,UACvD;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;","names":[]}