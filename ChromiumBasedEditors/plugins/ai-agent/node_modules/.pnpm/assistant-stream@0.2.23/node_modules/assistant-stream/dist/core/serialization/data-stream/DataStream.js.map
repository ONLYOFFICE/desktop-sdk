{"version":3,"sources":["../../../../src/core/serialization/data-stream/DataStream.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { ToolCallStreamController } from \"../../modules/tool-call\";\nimport { AssistantTransformStream } from \"../../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../../utils/stream/PipeableTransformStream\";\nimport { DataStreamChunk, DataStreamStreamChunkType } from \"./chunk-types\";\nimport { LineDecoderStream } from \"../../utils/stream/LineDecoderStream\";\nimport {\n  DataStreamChunkDecoder,\n  DataStreamChunkEncoder,\n} from \"./serialization\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../../utils/stream/AssistantMetaTransformStream\";\nimport { TextStreamController } from \"../../modules/text\";\nimport { AssistantStreamEncoder } from \"../../AssistantStream\";\n\nexport class DataStreamEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array<ArrayBuffer>>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        DataStreamChunk\n      >({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"part-start\": {\n              const part = chunk.part;\n              if (part.type === \"tool-call\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.StartToolCall,\n                  value,\n                });\n              }\n              if (part.type === \"source\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.Source,\n                  value,\n                });\n              }\n              break;\n            }\n            case \"text-delta\": {\n              const part = chunk.meta;\n              switch (part.type) {\n                case \"text\": {\n                  if (part.parentId) {\n                    controller.enqueue({\n                      type: DataStreamStreamChunkType.AuiTextDelta,\n                      value: {\n                        textDelta: chunk.textDelta,\n                        parentId: part.parentId,\n                      },\n                    });\n                  } else {\n                    controller.enqueue({\n                      type: DataStreamStreamChunkType.TextDelta,\n                      value: chunk.textDelta,\n                    });\n                  }\n                  break;\n                }\n                case \"reasoning\": {\n                  if (part.parentId) {\n                    controller.enqueue({\n                      type: DataStreamStreamChunkType.AuiReasoningDelta,\n                      value: {\n                        reasoningDelta: chunk.textDelta,\n                        parentId: part.parentId,\n                      },\n                    });\n                  } else {\n                    controller.enqueue({\n                      type: DataStreamStreamChunkType.ReasoningDelta,\n                      value: chunk.textDelta,\n                    });\n                  }\n                  break;\n                }\n                case \"tool-call\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.ToolCallArgsTextDelta,\n                    value: {\n                      toolCallId: part.toolCallId,\n                      argsTextDelta: chunk.textDelta,\n                    },\n                  });\n                  break;\n                }\n                default:\n                  throw new Error(\n                    `Unsupported part type for text-delta: ${part.type}`,\n                  );\n              }\n              break;\n            }\n            case \"result\": {\n              // Only tool-call parts can have results.\n              const part = chunk.meta;\n              if (part.type !== \"tool-call\") {\n                throw new Error(\n                  `Result chunk on non-tool-call part not supported: ${part.type}`,\n                );\n              }\n              controller.enqueue({\n                type: DataStreamStreamChunkType.ToolCallResult,\n                value: {\n                  toolCallId: part.toolCallId,\n                  result: chunk.result,\n                  artifact: chunk.artifact,\n                  ...(chunk.isError ? { isError: chunk.isError } : {}),\n                },\n              });\n              break;\n            }\n            case \"step-start\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.StartStep,\n                value,\n              });\n              break;\n            }\n            case \"step-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishStep,\n                value,\n              });\n              break;\n            }\n            case \"message-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishMessage,\n                value,\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Error,\n                value: chunk.error,\n              });\n              break;\n            }\n            case \"annotations\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Annotation,\n                value: chunk.annotations,\n              });\n              break;\n            }\n            case \"data\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Data,\n                value: chunk.data,\n              });\n              break;\n            }\n\n            case \"update-state\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.AuiUpdateStateOperations,\n                value: chunk.operations,\n              });\n              break;\n            }\n\n            // TODO ignore for now\n            // in the future, we should create a handler that waits for text parts to finish before continuing\n            case \"tool-call-args-text-finish\":\n            case \"part-finish\":\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`Unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform)\n        .pipeThrough(new DataStreamChunkEncoder())\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nconst TOOL_CALL_ARGS_CLOSING_CHUNKS = [\n  DataStreamStreamChunkType.StartToolCall,\n  DataStreamStreamChunkType.ToolCall,\n  DataStreamStreamChunkType.TextDelta,\n  DataStreamStreamChunkType.ReasoningDelta,\n  DataStreamStreamChunkType.Source,\n  DataStreamStreamChunkType.Error,\n  DataStreamStreamChunkType.FinishStep,\n  DataStreamStreamChunkType.FinishMessage,\n  DataStreamStreamChunkType.AuiTextDelta,\n  DataStreamStreamChunkType.AuiReasoningDelta,\n];\n\nexport class DataStreamDecoder extends PipeableTransformStream<\n  Uint8Array<ArrayBuffer>,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const toolCallControllers = new Map<string, ToolCallStreamController>();\n      let activeToolCallArgsText: TextStreamController | undefined;\n      const transform = new AssistantTransformStream<DataStreamChunk>({\n        transform(chunk, controller) {\n          const { type, value } = chunk;\n\n          if (TOOL_CALL_ARGS_CLOSING_CHUNKS.includes(type)) {\n            activeToolCallArgsText?.close();\n            activeToolCallArgsText = undefined;\n          }\n\n          switch (type) {\n            case DataStreamStreamChunkType.ReasoningDelta:\n              controller.appendReasoning(value);\n              break;\n\n            case DataStreamStreamChunkType.TextDelta:\n              controller.appendText(value);\n              break;\n\n            case DataStreamStreamChunkType.AuiTextDelta:\n              controller\n                .withParentId(value.parentId)\n                .appendText(value.textDelta);\n              break;\n\n            case DataStreamStreamChunkType.AuiReasoningDelta:\n              controller\n                .withParentId(value.parentId)\n                .appendReasoning(value.reasoningDelta);\n              break;\n\n            case DataStreamStreamChunkType.StartToolCall: {\n              const { toolCallId, toolName, parentId } = value;\n              const ctrl = parentId\n                ? controller.withParentId(parentId)\n                : controller;\n              const toolCallController = ctrl.addToolCallPart({\n                toolCallId,\n                toolName,\n              });\n              toolCallControllers.set(toolCallId, toolCallController);\n\n              activeToolCallArgsText = toolCallController.argsText;\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallArgsTextDelta: {\n              const { toolCallId, argsTextDelta } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call with unknown id: \" + toolCallId,\n                );\n              toolCallController.argsText.append(argsTextDelta);\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallResult: {\n              const { toolCallId, artifact, result, isError } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call result with unknown id: \" + toolCallId,\n                );\n              toolCallController.setResponse({\n                artifact,\n                result,\n                isError,\n              });\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCall: {\n              const { toolCallId, toolName, args } = value;\n\n              let toolCallController = toolCallControllers.get(toolCallId);\n              if (toolCallController) {\n                toolCallController.argsText.close();\n              } else {\n                toolCallController = controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                  args,\n                });\n                toolCallControllers.set(toolCallId, toolCallController);\n              }\n              break;\n            }\n\n            case DataStreamStreamChunkType.FinishMessage:\n              controller.enqueue({\n                type: \"message-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.StartStep:\n              controller.enqueue({\n                type: \"step-start\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.FinishStep:\n              controller.enqueue({\n                type: \"step-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n            case DataStreamStreamChunkType.Data:\n              controller.enqueue({\n                type: \"data\",\n                path: [],\n                data: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Annotation:\n              controller.enqueue({\n                type: \"annotations\",\n                path: [],\n                annotations: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Source: {\n              const { parentId, ...sourceData } = value;\n              const ctrl = parentId\n                ? controller.withParentId(parentId)\n                : controller;\n              ctrl.appendSource({\n                type: \"source\",\n                ...sourceData,\n              });\n              break;\n            }\n\n            case DataStreamStreamChunkType.Error:\n              controller.enqueue({\n                type: \"error\",\n                path: [],\n                error: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.File:\n              controller.appendFile({\n                type: \"file\",\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.AuiUpdateStateOperations:\n              controller.enqueue({\n                type: \"update-state\",\n                path: [],\n                operations: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.ReasoningSignature:\n            case DataStreamStreamChunkType.RedactedReasoning:\n              // ignore these for now\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n        flush() {\n          activeToolCallArgsText?.close();\n          activeToolCallArgsText = undefined;\n          toolCallControllers.forEach((controller) => controller.close());\n          toolCallControllers.clear();\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new LineDecoderStream())\n        .pipeThrough(new DataStreamChunkDecoder())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"mappings":"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","names":["type"]}