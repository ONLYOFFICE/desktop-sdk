{"version":3,"sources":["../../../src/core/modules/assistant-stream.ts"],"sourcesContent":["import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk, PartInit } from \"../AssistantStreamChunk\";\nimport { createMergeStream } from \"../utils/stream/merge\";\nimport { createTextStreamController, TextStreamController } from \"./text\";\nimport {\n  createToolCallStreamController,\n  ToolCallStreamController,\n} from \"./tool-call\";\nimport { Counter } from \"../utils/Counter\";\nimport {\n  PathAppendEncoder,\n  PathMergeEncoder,\n} from \"../utils/stream/path-utils\";\nimport { DataStreamEncoder } from \"../serialization/data-stream/DataStream\";\nimport { FilePart, SourcePart } from \"../utils/types\";\nimport { generateId } from \"../utils/generateId\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../utils/json/json-value\";\nimport { ToolResponseLike } from \"../tool/ToolResponse\";\nimport { promiseWithResolvers } from \"../../utils/promiseWithResolvers\";\n\ntype ToolCallPartInit = {\n  toolCallId?: string;\n  toolName: string;\n  argsText?: string;\n  args?: ReadonlyJSONObject;\n  response?: ToolResponseLike<ReadonlyJSONValue>;\n};\n\nexport type AssistantStreamController = {\n  appendText(textDelta: string): void;\n  appendReasoning(reasoningDelta: string): void;\n  appendSource(options: SourcePart): void;\n  appendFile(options: FilePart): void;\n  addTextPart(): TextStreamController;\n  addToolCallPart(options: string): ToolCallStreamController;\n  addToolCallPart(options: ToolCallPartInit): ToolCallStreamController;\n  enqueue(chunk: AssistantStreamChunk): void;\n  merge(stream: AssistantStream): void;\n  close(): void;\n  withParentId(parentId: string): AssistantStreamController;\n};\n\n// Shared state between controller instances\ntype AssistantStreamControllerState = {\n  merger: ReturnType<typeof createMergeStream>;\n  append?:\n    | {\n        controller: TextStreamController;\n        kind: \"text\" | \"reasoning\";\n      }\n    | undefined;\n  contentCounter: Counter;\n  closeSubscriber?: () => void;\n};\n\nclass AssistantStreamControllerImpl implements AssistantStreamController {\n  private readonly _state: AssistantStreamControllerState;\n  private _parentId?: string;\n\n  constructor(state?: AssistantStreamControllerState) {\n    this._state = state || {\n      merger: createMergeStream(),\n      contentCounter: new Counter(),\n    };\n  }\n\n  get __internal_isClosed() {\n    return this._state.merger.isSealed();\n  }\n\n  __internal_getReadable() {\n    return this._state.merger.readable;\n  }\n\n  __internal_subscribeToClose(callback: () => void) {\n    this._state.closeSubscriber = callback;\n  }\n\n  private _addPart(part: PartInit, stream: AssistantStream) {\n    if (this._state.append) {\n      this._state.append.controller.close();\n      this._state.append = undefined;\n    }\n\n    this.enqueue({\n      type: \"part-start\",\n      part,\n      path: [],\n    });\n    this._state.merger.addStream(\n      stream.pipeThrough(\n        new PathAppendEncoder(this._state.contentCounter.value),\n      ),\n    );\n  }\n\n  merge(stream: AssistantStream) {\n    this._state.merger.addStream(\n      stream.pipeThrough(new PathMergeEncoder(this._state.contentCounter)),\n    );\n  }\n\n  appendText(textDelta: string) {\n    if (this._state.append?.kind !== \"text\") {\n      this._state.append = {\n        kind: \"text\",\n        controller: this.addTextPart(),\n      };\n    }\n    this._state.append.controller.append(textDelta);\n  }\n\n  appendReasoning(textDelta: string) {\n    if (this._state.append?.kind !== \"reasoning\") {\n      this._state.append = {\n        kind: \"reasoning\",\n        controller: this.addReasoningPart(),\n      };\n    }\n    this._state.append.controller.append(textDelta);\n  }\n\n  addTextPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"text\" }, stream);\n    return controller;\n  }\n\n  addReasoningPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"reasoning\" }, stream);\n    return controller;\n  }\n\n  addToolCallPart(\n    options: string | ToolCallPartInit,\n  ): ToolCallStreamController {\n    const opt = typeof options === \"string\" ? { toolName: options } : options;\n    const toolName = opt.toolName;\n    const toolCallId = opt.toolCallId ?? generateId();\n\n    const [stream, controller] = createToolCallStreamController();\n    this._addPart(\n      {\n        type: \"tool-call\",\n        toolName,\n        toolCallId,\n        ...(this._parentId && { parentId: this._parentId }),\n      },\n      stream,\n    );\n\n    if (opt.argsText !== undefined) {\n      controller.argsText.append(opt.argsText);\n      controller.argsText.close();\n    }\n    if (opt.args !== undefined) {\n      controller.argsText.append(JSON.stringify(opt.args));\n      controller.argsText.close();\n    }\n    if (opt.response !== undefined) {\n      controller.setResponse(opt.response);\n    }\n\n    return controller;\n  }\n\n  appendSource(options: SourcePart) {\n    this._addPart(\n      { ...options, ...(this._parentId && { parentId: this._parentId }) },\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  appendFile(options: FilePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  enqueue(chunk: AssistantStreamChunk) {\n    this._state.merger.enqueue(chunk);\n\n    if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n      this._state.contentCounter.up();\n    }\n  }\n\n  withParentId(parentId: string): AssistantStreamController {\n    const controller = new AssistantStreamControllerImpl(this._state);\n    controller._parentId = parentId;\n    return controller;\n  }\n\n  close() {\n    this._state.merger.seal();\n    this._state.append?.controller?.close();\n\n    this._state.closeSubscriber?.();\n  }\n}\n\nexport function createAssistantStream(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n): AssistantStream {\n  const controller = new AssistantStreamControllerImpl();\n\n  let promiseOrVoid: PromiseLike<void> | void;\n  try {\n    promiseOrVoid = callback(controller);\n  } catch (e) {\n    if (!controller.__internal_isClosed) {\n      controller.enqueue({\n        type: \"error\",\n        path: [],\n        error: String(e),\n      });\n      controller.close();\n    }\n    throw e;\n  }\n\n  if (promiseOrVoid instanceof Promise) {\n    const runTask = async () => {\n      try {\n        await promiseOrVoid;\n      } catch (e) {\n        if (!controller.__internal_isClosed) {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(e),\n          });\n        }\n        throw e;\n      } finally {\n        if (!controller.__internal_isClosed) {\n          controller.close();\n        }\n      }\n    };\n    runTask();\n  } else {\n    if (!controller.__internal_isClosed) {\n      controller.close();\n    }\n  }\n\n  return controller.__internal_getReadable();\n}\n\nexport function createAssistantStreamController() {\n  const { resolve, promise } = promiseWithResolvers<void>();\n  let controller!: AssistantStreamController;\n  const stream = createAssistantStream((c) => {\n    controller = c;\n\n    (controller as AssistantStreamControllerImpl).__internal_subscribeToClose(\n      resolve,\n    );\n\n    return promise;\n  });\n  return [stream, controller] as const;\n}\n\nexport function createAssistantStreamResponse(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n) {\n  return AssistantStream.toResponse(\n    createAssistantStream(callback),\n    new DataStreamEncoder(),\n  );\n}\n"],"mappings":"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","names":[]}