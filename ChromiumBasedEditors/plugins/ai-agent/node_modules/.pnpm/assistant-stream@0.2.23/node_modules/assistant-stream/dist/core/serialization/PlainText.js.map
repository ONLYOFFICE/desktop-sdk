{"version":3,"sources":["../../../src/core/serialization/PlainText.ts"],"sourcesContent":["import { AssistantStreamEncoder } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { AssistantTransformStream } from \"../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\n\nexport class PlainTextEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array<ArrayBuffer>>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<AssistantStreamChunk, string>({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n\n            case \"part-start\":\n            case \"part-finish\":\n            case \"step-start\":\n            case \"step-finish\":\n            case \"message-finish\":\n            case \"error\":\n              break;\n\n            default:\n              const unsupportedType:\n                | \"tool-call-args-text-finish\"\n                | \"data\"\n                | \"annotations\"\n                | \"tool-call-begin\"\n                | \"tool-call-delta\"\n                | \"result\"\n                | \"update-state\" = type;\n              throw new Error(`unsupported chunk type: ${unsupportedType}`);\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(transform)\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nexport class PlainTextDecoder extends PipeableTransformStream<\n  Uint8Array<ArrayBuffer>,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const transform = new AssistantTransformStream<string>({\n        transform(chunk, controller) {\n          controller.appendText(chunk);\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"mappings":";AAEA,SAAS,gCAAgC;AACzC,SAAS,+BAA+B;AAEjC,IAAM,mBAAN,cACG,wBAEV;AAAA,EACE,UAAU,IAAI,QAAQ;AAAA,IACpB,gBAAgB;AAAA,IAChB,2BAA2B;AAAA,EAC7B,CAAC;AAAA,EAED,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,gBAA8C;AAAA,QAClE,UAAU,OAAO,YAAY;AAC3B,gBAAM,OAAO,MAAM;AACnB,kBAAQ,MAAM;AAAA,YACZ,KAAK;AACH,yBAAW,QAAQ,MAAM,SAAS;AAClC;AAAA,YAEF,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH;AAAA,YAEF;AACE,oBAAM,kBAOe;AACrB,oBAAM,IAAI,MAAM,2BAA2B,eAAe,EAAE;AAAA,UAChE;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,SAAS,EACrB,YAAY,IAAI,kBAAkB,CAAC;AAAA,IACxC,CAAC;AAAA,EACH;AACF;AAEO,IAAM,mBAAN,cAA+B,wBAGpC;AAAA,EACA,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,yBAAiC;AAAA,QACrD,UAAU,OAAO,YAAY;AAC3B,qBAAW,WAAW,KAAK;AAAA,QAC7B;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;","names":[]}