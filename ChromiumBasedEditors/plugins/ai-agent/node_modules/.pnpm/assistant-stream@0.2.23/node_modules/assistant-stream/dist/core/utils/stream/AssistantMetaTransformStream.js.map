{"version":3,"sources":["../../../../src/core/utils/stream/AssistantMetaTransformStream.ts"],"sourcesContent":["import { AssistantStreamChunk, PartInit } from \"../../AssistantStreamChunk\";\n\n/**\n * For chunk types that are associated with a part,\n * we require a nonâ€‘nullable meta field.\n */\nexport type AssistantMetaStreamChunk =\n  | (AssistantStreamChunk & {\n      type: \"text-delta\" | \"part-finish\";\n      meta: PartInit;\n    })\n  | (AssistantStreamChunk & {\n      type: \"result\" | \"tool-call-args-text-finish\";\n      meta: PartInit & { type: \"tool-call\" };\n    })\n  | (AssistantStreamChunk & {\n      type: Exclude<\n        AssistantStreamChunk[\"type\"],\n        \"text-delta\" | \"result\" | \"tool-call-args-text-finish\" | \"part-finish\"\n      >;\n    });\nexport class AssistantMetaTransformStream extends TransformStream<\n  AssistantStreamChunk,\n  AssistantMetaStreamChunk\n> {\n  constructor() {\n    // We use an array to record parts as they are introduced.\n    const parts: PartInit[] = [];\n\n    super({\n      transform(chunk, controller) {\n        // For chunks that introduce a new part.\n        if (chunk.type === \"part-start\") {\n          if (chunk.path.length !== 0) {\n            controller.error(new Error(\"Nested parts are not supported\"));\n            return;\n          }\n          parts.push(chunk.part);\n          controller.enqueue(chunk);\n          return;\n        }\n\n        // For chunks that expect an associated part.\n        if (\n          chunk.type === \"text-delta\" ||\n          chunk.type === \"result\" ||\n          chunk.type === \"part-finish\" ||\n          chunk.type === \"tool-call-args-text-finish\"\n        ) {\n          if (chunk.path.length !== 1) {\n            controller.error(\n              new Error(`${chunk.type} chunks must have a path of length 1`),\n            );\n            return;\n          }\n          const idx = chunk.path[0]!;\n          if (idx < 0 || idx >= parts.length) {\n            controller.error(new Error(`Invalid path index: ${idx}`));\n            return;\n          }\n          const part = parts[idx]!;\n\n          controller.enqueue({\n            ...chunk,\n            meta: part as any, // TODO\n          });\n          return;\n        }\n\n        controller.enqueue(chunk);\n      },\n    });\n  }\n}\n"],"mappings":";AAqBO,IAAM,+BAAN,cAA2C,gBAGhD;AAAA,EACA,cAAc;AAEZ,UAAM,QAAoB,CAAC;AAE3B,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAE3B,YAAI,MAAM,SAAS,cAAc;AAC/B,cAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,uBAAW,MAAM,IAAI,MAAM,gCAAgC,CAAC;AAC5D;AAAA,UACF;AACA,gBAAM,KAAK,MAAM,IAAI;AACrB,qBAAW,QAAQ,KAAK;AACxB;AAAA,QACF;AAGA,YACE,MAAM,SAAS,gBACf,MAAM,SAAS,YACf,MAAM,SAAS,iBACf,MAAM,SAAS,8BACf;AACA,cAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,uBAAW;AAAA,cACT,IAAI,MAAM,GAAG,MAAM,IAAI,sCAAsC;AAAA,YAC/D;AACA;AAAA,UACF;AACA,gBAAM,MAAM,MAAM,KAAK,CAAC;AACxB,cAAI,MAAM,KAAK,OAAO,MAAM,QAAQ;AAClC,uBAAW,MAAM,IAAI,MAAM,uBAAuB,GAAG,EAAE,CAAC;AACxD;AAAA,UACF;AACA,gBAAM,OAAO,MAAM,GAAG;AAEtB,qBAAW,QAAQ;AAAA,YACjB,GAAG;AAAA,YACH,MAAM;AAAA;AAAA,UACR,CAAC;AACD;AAAA,QACF;AAEA,mBAAW,QAAQ,KAAK;AAAA,MAC1B;AAAA,IACF,CAAC;AAAA,EACH;AACF;","names":[]}