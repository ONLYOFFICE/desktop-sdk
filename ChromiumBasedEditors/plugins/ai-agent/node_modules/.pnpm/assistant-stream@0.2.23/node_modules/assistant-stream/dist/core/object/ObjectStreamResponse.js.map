{"version":3,"sources":["../../../src/core/object/ObjectStreamResponse.ts"],"sourcesContent":["import { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\nimport { ObjectStreamAccumulator } from \"./ObjectStreamAccumulator\";\nimport { SSEDecoder, SSEEncoder } from \"../utils/stream/SSE\";\nimport { ObjectStreamChunk, ObjectStreamOperation } from \"./types\";\n\nexport class ObjectStreamEncoder extends PipeableTransformStream<\n  ObjectStreamChunk,\n  Uint8Array\n> {\n  constructor() {\n    super((readable) =>\n      readable\n        .pipeThrough(\n          (() => {\n            class ObjectStreamTransformer\n              implements\n                Transformer<ObjectStreamChunk, readonly ObjectStreamOperation[]>\n            {\n              #isFirstChunk = true;\n\n              start() {\n                // Nothing needed here since we initialize in the field declaration\n              }\n\n              transform(\n                chunk: ObjectStreamChunk,\n                controller: TransformStreamDefaultController<\n                  readonly ObjectStreamOperation[]\n                >,\n              ) {\n                if (\n                  this.#isFirstChunk &&\n                  chunk.snapshot &&\n                  Object.keys(chunk.snapshot).length > 0\n                ) {\n                  // For the first chunk, if there's an initial state that's not empty,\n                  // prepend a set operation for the initial state\n                  controller.enqueue([\n                    { type: \"set\", path: [], value: chunk.snapshot },\n                    ...chunk.operations,\n                  ]);\n                } else {\n                  controller.enqueue(chunk.operations);\n                }\n                this.#isFirstChunk = false;\n              }\n            }\n            return new TransformStream(new ObjectStreamTransformer());\n          })(),\n        )\n        .pipeThrough(new SSEEncoder()),\n    );\n  }\n}\n\nexport class ObjectStreamDecoder extends PipeableTransformStream<\n  Uint8Array<ArrayBuffer>,\n  ObjectStreamChunk\n> {\n  constructor() {\n    const accumulator = new ObjectStreamAccumulator();\n    super((readable) =>\n      readable\n        .pipeThrough(new SSEDecoder<readonly ObjectStreamOperation[]>())\n        .pipeThrough(\n          new TransformStream<\n            readonly ObjectStreamOperation[],\n            ObjectStreamChunk\n          >({\n            transform(operations, controller) {\n              accumulator.append(operations);\n              controller.enqueue({\n                snapshot: accumulator.state,\n                operations,\n              });\n            },\n          }),\n        ),\n    );\n  }\n}\n\nexport class ObjectStreamResponse extends Response {\n  constructor(body: ReadableStream<ObjectStreamChunk>) {\n    super(body.pipeThrough(new ObjectStreamEncoder()), {\n      headers: new Headers({\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n        \"Assistant-Stream-Format\": \"object-stream/v0\",\n      }),\n    });\n  }\n}\n\nexport const fromObjectStreamResponse = (\n  response: Response,\n): ReadableStream<ObjectStreamChunk> => {\n  if (!response.ok)\n    throw new Error(`Response failed, status ${response.status}`);\n  if (!response.body) throw new Error(\"Response body is null\");\n  if (response.headers.get(\"Content-Type\") !== \"text/event-stream\") {\n    throw new Error(\"Response is not an event stream\");\n  }\n  if (response.headers.get(\"Assistant-Stream-Format\") !== \"object-stream/v0\") {\n    throw new Error(\"Unsupported Assistant-Stream-Format header\");\n  }\n  return response.body.pipeThrough(new ObjectStreamDecoder());\n};\n"],"mappings":";AAAA,SAAS,+BAA+B;AACxC,SAAS,+BAA+B;AACxC,SAAS,YAAY,kBAAkB;AAGhC,IAAM,sBAAN,cAAkC,wBAGvC;AAAA,EACA,cAAc;AACZ;AAAA,MAAM,CAAC,aACL,SACG;AAAA,SACE,MAAM;AAAA,UACL,MAAM,wBAGN;AAAA,YACE,gBAAgB;AAAA,YAEhB,QAAQ;AAAA,YAER;AAAA,YAEA,UACE,OACA,YAGA;AACA,kBACE,KAAK,iBACL,MAAM,YACN,OAAO,KAAK,MAAM,QAAQ,EAAE,SAAS,GACrC;AAGA,2BAAW,QAAQ;AAAA,kBACjB,EAAE,MAAM,OAAO,MAAM,CAAC,GAAG,OAAO,MAAM,SAAS;AAAA,kBAC/C,GAAG,MAAM;AAAA,gBACX,CAAC;AAAA,cACH,OAAO;AACL,2BAAW,QAAQ,MAAM,UAAU;AAAA,cACrC;AACA,mBAAK,gBAAgB;AAAA,YACvB;AAAA,UACF;AACA,iBAAO,IAAI,gBAAgB,IAAI,wBAAwB,CAAC;AAAA,QAC1D,GAAG;AAAA,MACL,EACC,YAAY,IAAI,WAAW,CAAC;AAAA,IACjC;AAAA,EACF;AACF;AAEO,IAAM,sBAAN,cAAkC,wBAGvC;AAAA,EACA,cAAc;AACZ,UAAM,cAAc,IAAI,wBAAwB;AAChD;AAAA,MAAM,CAAC,aACL,SACG,YAAY,IAAI,WAA6C,CAAC,EAC9D;AAAA,QACC,IAAI,gBAGF;AAAA,UACA,UAAU,YAAY,YAAY;AAChC,wBAAY,OAAO,UAAU;AAC7B,uBAAW,QAAQ;AAAA,cACjB,UAAU,YAAY;AAAA,cACtB;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACJ;AAAA,EACF;AACF;AAEO,IAAM,uBAAN,cAAmC,SAAS;AAAA,EACjD,YAAY,MAAyC;AACnD,UAAM,KAAK,YAAY,IAAI,oBAAoB,CAAC,GAAG;AAAA,MACjD,SAAS,IAAI,QAAQ;AAAA,QACnB,gBAAgB;AAAA,QAChB,iBAAiB;AAAA,QACjB,YAAY;AAAA,QACZ,2BAA2B;AAAA,MAC7B,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACF;AAEO,IAAM,2BAA2B,CACtC,aACsC;AACtC,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,2BAA2B,SAAS,MAAM,EAAE;AAC9D,MAAI,CAAC,SAAS,KAAM,OAAM,IAAI,MAAM,uBAAuB;AAC3D,MAAI,SAAS,QAAQ,IAAI,cAAc,MAAM,qBAAqB;AAChE,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,MAAI,SAAS,QAAQ,IAAI,yBAAyB,MAAM,oBAAoB;AAC1E,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AACA,SAAO,SAAS,KAAK,YAAY,IAAI,oBAAoB,CAAC;AAC5D;","names":[]}