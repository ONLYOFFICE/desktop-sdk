{"version":3,"sources":["../../../src/core/object/ObjectStreamAccumulator.ts"],"sourcesContent":["import { ReadonlyJSONValue, ReadonlyJSONObject } from \"../../utils\";\nimport { ObjectStreamOperation } from \"./types\";\n\nexport class ObjectStreamAccumulator {\n  private _state: ReadonlyJSONValue;\n\n  constructor(initialValue: ReadonlyJSONValue = null) {\n    this._state = initialValue;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  append(ops: readonly ObjectStreamOperation[]) {\n    this._state = ops.reduce(\n      (state, op) => ObjectStreamAccumulator.apply(state, op),\n      this._state,\n    );\n  }\n\n  private static apply(state: ReadonlyJSONValue, op: ObjectStreamOperation) {\n    const type = op.type;\n    switch (type) {\n      case \"set\":\n        return ObjectStreamAccumulator.updatePath(\n          state,\n          op.path,\n          () => op.value,\n        );\n      case \"append-text\":\n        return ObjectStreamAccumulator.updatePath(state, op.path, (current) => {\n          if (typeof current !== \"string\")\n            throw new Error(`Expected string at path [${op.path.join(\", \")}]`);\n          return current + op.value;\n        });\n\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Invalid operation type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  private static updatePath(\n    state: ReadonlyJSONValue | undefined,\n    path: readonly string[],\n    updater: (current: ReadonlyJSONValue | undefined) => ReadonlyJSONValue,\n  ): ReadonlyJSONValue {\n    if (path.length === 0) return updater(state);\n\n    // Initialize state as empty object if it's null and we're trying to set a property\n    state ??= {};\n\n    if (typeof state !== \"object\") {\n      throw new Error(`Invalid path: [${path.join(\", \")}]`);\n    }\n\n    const [key, ...rest] = path as [string, ...(readonly string[])];\n    if (Array.isArray(state)) {\n      const idx = Number(key);\n      if (isNaN(idx))\n        throw new Error(`Expected array index at [${path.join(\", \")}]`);\n      if (idx > state.length || idx < 0)\n        throw new Error(`Insert array index out of bounds`);\n\n      const nextState = [...state];\n      nextState[idx] = this.updatePath(nextState[idx], rest, updater);\n\n      return nextState;\n    }\n\n    const nextState = { ...(state as ReadonlyJSONObject) };\n    nextState[key] = this.updatePath(nextState[key], rest, updater);\n\n    return nextState;\n  }\n}\n"],"mappings":";AAGO,IAAM,0BAAN,MAAM,yBAAwB;AAAA,EAC3B;AAAA,EAER,YAAY,eAAkC,MAAM;AAClD,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,OAAO,KAAuC;AAC5C,SAAK,SAAS,IAAI;AAAA,MAChB,CAAC,OAAO,OAAO,yBAAwB,MAAM,OAAO,EAAE;AAAA,MACtD,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EAEA,OAAe,MAAM,OAA0B,IAA2B;AACxE,UAAM,OAAO,GAAG;AAChB,YAAQ,MAAM;AAAA,MACZ,KAAK;AACH,eAAO,yBAAwB;AAAA,UAC7B;AAAA,UACA,GAAG;AAAA,UACH,MAAM,GAAG;AAAA,QACX;AAAA,MACF,KAAK;AACH,eAAO,yBAAwB,WAAW,OAAO,GAAG,MAAM,CAAC,YAAY;AACrE,cAAI,OAAO,YAAY;AACrB,kBAAM,IAAI,MAAM,4BAA4B,GAAG,KAAK,KAAK,IAAI,CAAC,GAAG;AACnE,iBAAO,UAAU,GAAG;AAAA,QACtB,CAAC;AAAA,MAEH,SAAS;AACP,cAAM,mBAA0B;AAChC,cAAM,IAAI,MAAM,2BAA2B,gBAAgB,EAAE;AAAA,MAC/D;AAAA,IACF;AAAA,EACF;AAAA,EAEA,OAAe,WACb,OACA,MACA,SACmB;AACnB,QAAI,KAAK,WAAW,EAAG,QAAO,QAAQ,KAAK;AAG3C,cAAU,CAAC;AAEX,QAAI,OAAO,UAAU,UAAU;AAC7B,YAAM,IAAI,MAAM,kBAAkB,KAAK,KAAK,IAAI,CAAC,GAAG;AAAA,IACtD;AAEA,UAAM,CAAC,KAAK,GAAG,IAAI,IAAI;AACvB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,YAAM,MAAM,OAAO,GAAG;AACtB,UAAI,MAAM,GAAG;AACX,cAAM,IAAI,MAAM,4BAA4B,KAAK,KAAK,IAAI,CAAC,GAAG;AAChE,UAAI,MAAM,MAAM,UAAU,MAAM;AAC9B,cAAM,IAAI,MAAM,kCAAkC;AAEpD,YAAMA,aAAY,CAAC,GAAG,KAAK;AAC3B,MAAAA,WAAU,GAAG,IAAI,KAAK,WAAWA,WAAU,GAAG,GAAG,MAAM,OAAO;AAE9D,aAAOA;AAAA,IACT;AAEA,UAAM,YAAY,EAAE,GAAI,MAA6B;AACrD,cAAU,GAAG,IAAI,KAAK,WAAW,UAAU,GAAG,GAAG,MAAM,OAAO;AAE9D,WAAO;AAAA,EACT;AACF;","names":["nextState"]}