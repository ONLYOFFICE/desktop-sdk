{"version":3,"sources":["../../../src/core/tool/ToolExecutionStream.ts"],"sourcesContent":["import sjson from \"secure-json-parse\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../utils/stream/AssistantMetaTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../../utils/json/json-value\";\nimport { ToolResponse } from \"./ToolResponse\";\nimport { withPromiseOrValue } from \"../utils/withPromiseOrValue\";\nimport { ToolCallReaderImpl } from \"./ToolCallReader\";\nimport { ToolCallReader } from \"./tool-types\";\n\ntype ToolCallback = (toolCall: {\n  toolCallId: string;\n  toolName: string;\n  args: ReadonlyJSONObject;\n}) =>\n  | Promise<ToolResponse<ReadonlyJSONValue>>\n  | ToolResponse<ReadonlyJSONValue>\n  | undefined;\n\ntype ToolStreamCallback = <\n  TArgs extends ReadonlyJSONObject = ReadonlyJSONObject,\n  TResult extends ReadonlyJSONValue = ReadonlyJSONValue,\n>(toolCall: {\n  reader: ToolCallReader<TArgs, TResult>;\n  toolCallId: string;\n  toolName: string;\n}) => void;\n\ntype ToolExecutionOptions = {\n  execute: ToolCallback;\n  streamCall: ToolStreamCallback;\n};\n\nexport class ToolExecutionStream extends PipeableTransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(options: ToolExecutionOptions) {\n    const toolCallPromises = new Map<string, PromiseLike<void>>();\n    const toolCallControllers = new Map<\n      string,\n      ToolCallReaderImpl<ReadonlyJSONObject, ReadonlyJSONValue>\n    >();\n\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        AssistantStreamChunk\n      >({\n        transform(chunk, controller) {\n          // forward everything\n          if (chunk.type !== \"part-finish\" || chunk.meta.type !== \"tool-call\") {\n            controller.enqueue(chunk);\n          }\n\n          const type = chunk.type;\n\n          switch (type) {\n            case \"part-start\":\n              if (chunk.part.type === \"tool-call\") {\n                const reader = new ToolCallReaderImpl<\n                  ReadonlyJSONObject,\n                  ReadonlyJSONValue\n                >();\n                toolCallControllers.set(chunk.part.toolCallId, reader);\n\n                options.streamCall({\n                  reader,\n                  toolCallId: chunk.part.toolCallId,\n                  toolName: chunk.part.toolName,\n                });\n              }\n              break;\n            case \"text-delta\": {\n              if (chunk.meta.type === \"tool-call\") {\n                const toolCallId = chunk.meta.toolCallId;\n\n                const controller = toolCallControllers.get(toolCallId);\n                if (!controller)\n                  throw new Error(\"No controller found for tool call\");\n                controller.appendArgsTextDelta(chunk.textDelta);\n              }\n              break;\n            }\n            case \"result\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId } = chunk.meta;\n              const controller = toolCallControllers.get(toolCallId);\n              if (!controller)\n                throw new Error(\"No controller found for tool call\");\n              controller.setResponse(\n                new ToolResponse({\n                  result: chunk.result,\n                  artifact: chunk.artifact,\n                  isError: chunk.isError,\n                }),\n              );\n              break;\n            }\n            case \"tool-call-args-text-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId, toolName } = chunk.meta;\n              const streamController = toolCallControllers.get(toolCallId)!;\n              if (!streamController)\n                throw new Error(\"No controller found for tool call\");\n\n              const promise = withPromiseOrValue(\n                () => {\n                  let args;\n                  try {\n                    args = sjson.parse(streamController.argsText);\n                  } catch (e) {\n                    throw new Error(\n                      `Function parameter parsing failed. ${JSON.stringify((e as Error).message)}`,\n                    );\n                  }\n\n                  return options.execute({\n                    toolCallId,\n                    toolName,\n                    args,\n                  });\n                },\n                (c) => {\n                  if (c === undefined) return;\n\n                  // TODO how to handle new ToolResult({ result: undefined })?\n                  const result = new ToolResponse({\n                    artifact: c.artifact,\n                    result: c.result,\n                    isError: c.isError,\n                  });\n                  streamController.setResponse(result);\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    ...result,\n                  });\n                },\n                (e) => {\n                  const result = new ToolResponse({\n                    result: String(e),\n                    isError: true,\n                  });\n\n                  streamController.setResponse(result);\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    ...result,\n                  });\n                },\n              );\n              if (promise) {\n                toolCallPromises.set(toolCallId, promise);\n              }\n              break;\n            }\n\n            case \"part-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId } = chunk.meta;\n              const toolCallPromise = toolCallPromises.get(toolCallId);\n              if (toolCallPromise) {\n                toolCallPromise.then(() => {\n                  toolCallPromises.delete(toolCallId);\n                  toolCallControllers.delete(toolCallId);\n\n                  controller.enqueue(chunk);\n                });\n              } else {\n                controller.enqueue(chunk);\n              }\n            }\n          }\n        },\n        async flush() {\n          await Promise.all(toolCallPromises.values());\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n"],"mappings":"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","names":["controller"]}