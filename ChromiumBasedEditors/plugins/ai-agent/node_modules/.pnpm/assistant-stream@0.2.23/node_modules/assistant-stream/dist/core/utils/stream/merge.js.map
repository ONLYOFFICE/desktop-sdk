{"version":3,"sources":["../../../../src/core/utils/stream/merge.ts"],"sourcesContent":["import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { promiseWithResolvers } from \"../../../utils/promiseWithResolvers\";\n\ntype MergeStreamItem = {\n  reader: ReadableStreamDefaultReader<AssistantStreamChunk>;\n  promise?: Promise<unknown> | undefined;\n};\n\nexport const createMergeStream = () => {\n  const list: MergeStreamItem[] = [];\n  let sealed = false;\n  let controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  let currentPull: ReturnType<typeof promiseWithResolvers<void>> | undefined;\n\n  const handlePull = (item: MergeStreamItem) => {\n    if (!item.promise) {\n      // TODO for most streams, we can directly pipeTo to avoid the microTask queue\n      // add an option to eagerly pipe the stream to the merge stream\n      // ideally, using assitant-stream w sync run method + piping to a sync WritableStream runs in the same microtask\n      // this is useful because we often use AssistantStreams internally as a serialization utility, e. g. AssistantTransformStream\n      // idea: avoid reader.read() by instead using a WritableStream & if (!hasPendingPull) await waitForPull()?\n      item.promise = item.reader\n        .read()\n        .then(({ done, value }) => {\n          item.promise = undefined;\n          if (done) {\n            list.splice(list.indexOf(item), 1);\n            if (sealed && list.length === 0) {\n              controller.close();\n            }\n          } else {\n            controller.enqueue(value);\n          }\n\n          currentPull?.resolve();\n          currentPull = undefined;\n        })\n        .catch((e) => {\n          console.error(e);\n\n          list.forEach((item) => {\n            item.reader.cancel();\n          });\n          list.length = 0;\n\n          controller.error(e);\n\n          currentPull?.reject(e);\n          currentPull = undefined;\n        });\n    }\n  };\n\n  const readable = new ReadableStream<AssistantStreamChunk>({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      currentPull = promiseWithResolvers();\n      list.forEach((item) => {\n        handlePull(item);\n      });\n\n      return currentPull.promise;\n    },\n    cancel() {\n      list.forEach((item) => {\n        item.reader.cancel();\n      });\n      list.length = 0;\n    },\n  });\n\n  return {\n    readable,\n    isSealed() {\n      return sealed;\n    },\n    seal() {\n      sealed = true;\n      if (list.length === 0) controller.close();\n    },\n    addStream(stream: ReadableStream<AssistantStreamChunk>) {\n      if (sealed)\n        throw new Error(\n          \"Cannot add streams after the run callback has settled.\",\n        );\n\n      const item = { reader: stream.getReader() };\n      list.push(item);\n      handlePull(item);\n    },\n    enqueue(chunk: AssistantStreamChunk) {\n      this.addStream(\n        new ReadableStream({\n          start(c) {\n            c.enqueue(chunk);\n            c.close();\n          },\n        }),\n      );\n    },\n  };\n};\n\n// TODO\n// export class SpanContainerMerger {\n//   public get isSealed() {\n//     return this.mergeStream.isSealed();\n//   }\n\n//   public get readable() {\n//     return this.mergeStream.readable;\n//   }\n\n//   private subAllocator = new Counter();\n//   private mergeStream = createMergeStream();\n\n//   constructor() {\n//     // id 0 is auto allocated\n//     this.subAllocator.up();\n//   }\n\n//   add(stream: ReadableStream<AssistantStreamChunk>) {\n//     this.mergeStream.addStream(\n//       stream.pipeThrough(new SpanParentEncoder(this.subAllocator)),\n//     );\n//   }\n\n//   enqueue(chunk: AssistantStreamChunk & { parentId: 0 }) {\n//     this.mergeStream.addStream(\n//       new ReadableStream({\n//         start(c) {\n//           c.enqueue(chunk);\n//           c.close();\n//         },\n//       }),\n//     );\n//   }\n\n//   seal() {\n//     this.mergeStream.seal();\n//   }\n// }\n\n// export class SpanContainerSplitter {\n//   public writable;\n\n//   private isSealed = false;\n//   private writers = new Map<\n//     number,\n//     WritableStreamDefaultWriter<AssistantStreamChunk>\n//   >();\n\n//   private closeTasks: Promise<void>[] = [];\n\n//   private allocator = new Counter();\n//   private subAllocator = new Counter();\n\n//   constructor() {\n//     // id 0 is auto-allocated\n//     this.allocator.up();\n\n//     this.writable = new WritableStream({\n//       write: (chunk) => {\n//         const { type, parentId } = chunk;\n\n//         const writer = this.writers.get(parentId);\n//         if (writer === undefined) throw new Error(\"Parent id not found\");\n\n//         writer.write(chunk);\n\n//         if (type === \"span\") {\n//           // allocate a new span id\n//           this.writers.set(this.allocator.up(), writer);\n//         }\n//         if (type === \"finish\") {\n//           this.writers.delete(parentId);\n//           writer.close();\n\n//           if (this.writers.size === 0) {\n//             const closeTask = this.writable.close();\n//             this.closeTasks.push(closeTask);\n//             closeTask.then(() => {\n//               this.closeTasks.splice(this.closeTasks.indexOf(closeTask), 1);\n//             });\n//           }\n//         }\n//       },\n//       close: async () => {\n//         if (this.writers.size > 0) throw new Error(\"Not all writers closed\");\n\n//         // await and throw on any errors\n//         await Promise.all(this.closeTasks);\n//       },\n//     });\n//   }\n\n//   add(stream: WritableStream<AssistantStreamChunk>) {\n//     if (this.isSealed) throw new Error(\"Cannot add streams after sealing\");\n\n//     const decoder = new SpanParentDecoder(this.subAllocator);\n//     decoder.readable.pipeTo(stream);\n\n//     this.writers.set(this.allocator.up(), decoder.writable.getWriter());\n//   }\n\n//   seal() {\n//     this.isSealed = true;\n//     if (this.writers.size === 0) this.writable.close();\n//   }\n// }\n"],"mappings":";AACA,SAAS,4BAA4B;AAO9B,IAAM,oBAAoB,MAAM;AACrC,QAAM,OAA0B,CAAC;AACjC,MAAI,SAAS;AACb,MAAI;AACJ,MAAI;AAEJ,QAAM,aAAa,CAAC,SAA0B;AAC5C,QAAI,CAAC,KAAK,SAAS;AAMjB,WAAK,UAAU,KAAK,OACjB,KAAK,EACL,KAAK,CAAC,EAAE,MAAM,MAAM,MAAM;AACzB,aAAK,UAAU;AACf,YAAI,MAAM;AACR,eAAK,OAAO,KAAK,QAAQ,IAAI,GAAG,CAAC;AACjC,cAAI,UAAU,KAAK,WAAW,GAAG;AAC/B,uBAAW,MAAM;AAAA,UACnB;AAAA,QACF,OAAO;AACL,qBAAW,QAAQ,KAAK;AAAA,QAC1B;AAEA,qBAAa,QAAQ;AACrB,sBAAc;AAAA,MAChB,CAAC,EACA,MAAM,CAAC,MAAM;AACZ,gBAAQ,MAAM,CAAC;AAEf,aAAK,QAAQ,CAACA,UAAS;AACrB,UAAAA,MAAK,OAAO,OAAO;AAAA,QACrB,CAAC;AACD,aAAK,SAAS;AAEd,mBAAW,MAAM,CAAC;AAElB,qBAAa,OAAO,CAAC;AACrB,sBAAc;AAAA,MAChB,CAAC;AAAA,IACL;AAAA,EACF;AAEA,QAAM,WAAW,IAAI,eAAqC;AAAA,IACxD,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,IACA,OAAO;AACL,oBAAc,qBAAqB;AACnC,WAAK,QAAQ,CAAC,SAAS;AACrB,mBAAW,IAAI;AAAA,MACjB,CAAC;AAED,aAAO,YAAY;AAAA,IACrB;AAAA,IACA,SAAS;AACP,WAAK,QAAQ,CAAC,SAAS;AACrB,aAAK,OAAO,OAAO;AAAA,MACrB,CAAC;AACD,WAAK,SAAS;AAAA,IAChB;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,OAAO;AACL,eAAS;AACT,UAAI,KAAK,WAAW,EAAG,YAAW,MAAM;AAAA,IAC1C;AAAA,IACA,UAAU,QAA8C;AACtD,UAAI;AACF,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAEF,YAAM,OAAO,EAAE,QAAQ,OAAO,UAAU,EAAE;AAC1C,WAAK,KAAK,IAAI;AACd,iBAAW,IAAI;AAAA,IACjB;AAAA,IACA,QAAQ,OAA6B;AACnC,WAAK;AAAA,QACH,IAAI,eAAe;AAAA,UACjB,MAAM,GAAG;AACP,cAAE,QAAQ,KAAK;AACf,cAAE,MAAM;AAAA,UACV;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;","names":["item"]}